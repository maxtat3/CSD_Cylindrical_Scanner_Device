   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_11
  12               	__vector_11:
  13               	.LFB12:
  14               		.file 1 "main.c"
   1:main.c        **** #include <avr/io.h>
   2:main.c        **** #include <util/delay.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/atomic.h>
   5:main.c        **** #include <stdbool.h>
   6:main.c        **** 
   7:main.c        **** 
   8:main.c        **** #define		SetBit(reg, bit)		reg |= (1<<bit)		//–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–∏—Ç –≤ "1" (bit) –≤ —Ä–µ–≥–∏—
   9:main.c        **** #define		ClearBit(reg, bit)		reg &= (~(1<<bit))	//–°–±—Ä–æ—Å–∏—Ç—å  –±–∏—Ç (bit) –≤ —Ä–µ–≥–∏—Å—Ç—Ä–
  10:main.c        **** #define		IsSetBit(reg, bit)		((reg & (1<<bit)) != 0)	//–ü—Ä–æ–≤–µ—Ä–∫–∞, —É—Å—Ç–∞–Ω–æ–≤–ª–µ –ª–∏  —
  11:main.c        **** #define		IsClearBit(reg, bit)		((reg & (1<<bit)) == 0)	//–ü—Ä–æ–≤–µ—Ä–∫–∞, –æ—á–∏—â–µ–Ω –ª–∏ —Ä–∞–∑
  12:main.c        **** 
  13:main.c        **** // ==========================================
  14:main.c        **** // 			–®–∞–≥–æ–≤—ã–π –¥–≤–∏–≥–∞—Ç–µ–ª—å
  15:main.c        **** // ==========================================
  16:main.c        **** /* –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ –ø–æ—Ä—Ç–∞ –∫ –∫–æ—Ç–æ—Ä–º—É –ø–æ–¥–∫–ª—é—á–µ–Ω —à–∞–≥
  17:main.c        **** #define		SM_PORT		PORTD		
  18:main.c        **** #define		SM_PIN		PIND
  19:main.c        **** #define		SM_DDR		DDRD
  20:main.c        **** 
  21:main.c        **** /* –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –Ω–æ–º–µ—Ä–æ–≤ –ø–æ—Ä—Ç–æ–≤ –∫ –∫–æ—Ç—Ä—ã–º –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –æ–±–º–æ
  22:main.c        **** #define		SM_WIRE_1	4
  23:main.c        **** #define		SM_WIRE_2	5
  24:main.c        **** #define		SM_WIRE_3	6
  25:main.c        **** #define		SM_WIRE_4	7
  26:main.c        **** 
  27:main.c        **** // ==========================================
  28:main.c        **** // 			–û–ø—Ç–æ-–ø—Ä–µ—Ä—ã–≤–∞—Ç–µ–ª—å —Å –æ—Ç–∫—Ä—ã—Ç—ã–º –∫–∞–Ω–∞–ª–æ–º 
  29:main.c        **** // 			–î–∞—Ç—á–∏–∫ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —à–∞–≥–æ–≤–æ–≥–æ –¥–≤–∏–≥–∞—Ç–µ–ª—è
  30:main.c        **** // ==========================================
  31:main.c        **** /* –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ –ø–æ—Ä—Ç–∞ –∫ –∫–æ—Ç–æ—Ä–º—É –ø–æ–¥–∫–ª—é—á–µ–Ω –æ–ø—Ç
  32:main.c        **** #define		OPTO_SENSOR_PORT	PORTB
  33:main.c        **** #define		OPTO_SENSOR_DDR		DDRB
  34:main.c        **** #define		OPTO_SENSOR_PIN		PINB
  35:main.c        **** 
  36:main.c        **** /* –ù–æ–º–µ—Ä –ø–æ—Ä—Ç–∞ –∫ –∫–æ—Ç–æ—Ä–æ–º—É –ø–æ–¥–∫–ª—é—á–µ–Ω –æ–ø—Ç–æ-–ø—Ä–µ—Ä—ã–≤–∞—Ç–µ–ª—å*/
  37:main.c        **** #define		OPTO_SENSOR		0
  38:main.c        **** 
  39:main.c        **** // ==========================================
  40:main.c        **** // 			Led1 –¥–ª—è –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è
  41:main.c        **** // ==========================================
  42:main.c        **** /* –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ –¥–ª—è logging led1 */
  43:main.c        **** #define		STATE_LED_PORT		PORTB
  44:main.c        **** #define		STATE_LED_DDR		DDRB
  45:main.c        **** 
  46:main.c        **** /* –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –Ω–æ–º–µ—Ä–∞ –ø–æ—Ä—Ç–≤ –∫ –∫–æ—Ç–æ—Ä—ã–º –ø–æ–¥–∫–ª—é—á–µ–Ω logging led1
  47:main.c        **** #define 	STATE_LED 		1
  48:main.c        **** 
  49:main.c        **** // ==========================================
  50:main.c        **** // 			–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¢–°1, –æ—Ç–≤–µ—á–∞—é—â–µ–≥–æ –∑–∞
  51:main.c        **** //			–≤—Ä–∞—â–µ–Ω–∏–µ –®–î
  52:main.c        **** // ==========================================
  53:main.c        **** /* –ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞ TCNT1, –≤—ã–±–∏—Ä–∞–µ—Ç—å—Å—è –≤ –∑–∞–≤–∏—Å
  54:main.c        **** #define 	TCNT1_START_VAL		64000
  55:main.c        **** 
  56:main.c        **** /* –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ –≤ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏. –
  57:main.c        **** // #define		SM_MAX_PROGREESS	300
  58:main.c        **** 
  59:main.c        **** // ==========================================
  60:main.c        **** // 			–î—Ä—É–≥–∏–µ –º–∞–∫—Ä–æ—Å—ã
  61:main.c        **** // ==========================================
  62:main.c        **** /* –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–Ω—ã—Ö –ø–æ–≤–æ—Ä–æ—Ç–æ–≤ —Ä–æ—Ç–æ—Ä–∞ –®–î –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω
  63:main.c        **** #define 	SM_FULL_ONE_ROTATE_1CM	9
  64:main.c        **** 
  65:main.c        **** /* –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ —Ä–æ—Ç–æ—Ä–∞ –®–î –ø—Ä–∏ –ø–æ–ª–Ω–æ–º –æ–±–æ—Ä–æ—Ç–µ –Ω–∞ 360 –≥
  66:main.c        **** #define 	SM_ONEROTATE_360_DEGR	95
  67:main.c        **** 
  68:main.c        **** /* –ü–æ–ª–Ω–∞—è –¥–ª–∏–Ω–∞ (—Å–º) –Ω–∞ –∫–æ—Ç–æ—Ä—É—é –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—å—Å—è –∫–∞—Ä–µ—Ç–∫–∞, –¥
  69:main.c        **** #define 	FULL_LENGTH_CM			6
  70:main.c        **** 
  71:main.c        **** /* –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —à–∞–≥–æ–≤ –®–î –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∫–∞—Ä–µ
  72:main.c        **** #define		SM_FULL_MSR_STEPS		SM_FULL_ONE_ROTATE_1CM * SM_ONEROTATE_360_DEGR * FULL_LENGTH_CM
  73:main.c        **** 
  74:main.c        **** 
  75:main.c        **** /* –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∫–∞–∂–¥—ã–º —à–∞–≥–æ–º –ø—Ä–∏ –≤—Ä–µ—â–µ–Ω–∏–∏ –®–î, —ç—Ç–æ –æ–ø—Ä–
  76:main.c        **** #define		SM_DELAY_STEP_MS	10
  77:main.c        **** 
  78:main.c        **** 
  79:main.c        **** /* –í—ã–ø–æ–ª–Ω–µ–Ω –ª–∏ –∑–∞—Ö–≤–∞—Ç –¢–°1, —Ç.–µ. –≤–∫–ª—é—á–µ–Ω –æ–Ω (–®–î –≤—Ä–∞—â–∞–µ—Ç—å—Å—è)
  80:main.c        **** volatile bool isBlockTC1 = false;
  81:main.c        **** 
  82:main.c        **** // –∑–∞–ø–æ–º–∏–Ω–∞–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–Ω–æ–ø–∫–∏ –∑–∞–ø—É—Å–∫–∞/–æ—Å—Ç–∞–Ω–
  83:main.c        **** volatile bool btnStateFlag = false;
  84:main.c        **** 
  85:main.c        **** volatile unsigned char usartRxBuf = 0;	//–æ–¥–Ω–æ–±–∞–π—Ç–Ω—ã–π –±—É—Ñ–µ—Ä
  86:main.c        **** volatile unsigned char lowByte; // –º–ª–∞–¥—à–∏–π –±–∞–π—Ç –∞—Ü–ø –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
  87:main.c        **** volatile unsigned int adcResult; // —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞—Ü–ø 
  88:main.c        **** 
  89:main.c        **** // —Ç–∞–±–ª–∏—Ü–∞ —à–∞–≥–æ–≤ –®–î , –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π —à–∞–≥
  90:main.c        **** // const char smTableNormalStep[] = {_BV(SM_WIRE_1), _BV(SM_WIRE_2), _BV(SM_WIRE_3), _BV(SM_WIRE_4)
  91:main.c        **** const char smTableNormalStep[] = {_BV(SM_WIRE_4), _BV(SM_WIRE_3), _BV(SM_WIRE_2), _BV(SM_WIRE_1)};
  92:main.c        **** 
  93:main.c        **** //======================================
  94:main.c        **** //	–ö–æ–º–∞–Ω–¥—ã –æ—Ç –ü–ö
  95:main.c        **** //	–ö–∞–∂–¥–∞—è –∫–æ–º–∞–Ω–¥–∞ - –º–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤
  96:main.c        **** //======================================
  97:main.c        **** char pcToMcuStartMeasureComm[] = {'a', 'q', 'l'};
  98:main.c        **** char pcToMcuStopMeasureComm[] = {'a', 'b', 'k'};
  99:main.c        **** int commCount = 0; //–æ–±—â–∏–π —Å—á–µ—Ç—á–∏–∫ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –
 100:main.c        **** /* –ü–µ—Ä–µ—á–∏—Å–ª–µ–≥–Ω–∏–µ –∫–æ–º–∞–Ω–¥ –æ—Ç –ü–ö */
 101:main.c        **** enum fromPcCommands{
 102:main.c        **** 	STDBY,
 103:main.c        **** 	DO_START_SM,
 104:main.c        **** 	DO_STOP_SM
 105:main.c        **** };
 106:main.c        **** volatile enum fromPcCommands pcCommand = STDBY;
 107:main.c        **** 
 108:main.c        **** 
 109:main.c        **** 
 110:main.c        **** void initIO(void);
 111:main.c        **** void initUSART(void);
 112:main.c        **** void initADC(void);
 113:main.c        **** void initExtInt0(void);
 114:main.c        **** void turnOnTC1(void);
 115:main.c        **** void turnOffTC1(void);
 116:main.c        **** void sendCharToUSART(unsigned char sym);
 117:main.c        **** unsigned char getCharOfUSART(void);
 118:main.c        **** bool checkSMInBeginPos(void);
 119:main.c        **** void stopSM(void);
 120:main.c        **** void blinkLed1r();
 121:main.c        **** void blinkLed2r();
 122:main.c        **** 
 123:main.c        **** 
 124:main.c        **** 
 125:main.c        **** int main(void){
 126:main.c        **** 	cli();
 127:main.c        **** 	initIO();
 128:main.c        **** 	initUSART();
 129:main.c        **** 	initADC();
 130:main.c        **** 	initExtInt0();
 131:main.c        **** 	sei();
 132:main.c        **** 
 133:main.c        **** 	checkSMInBeginPos();
 134:main.c        **** 
 135:main.c        **** 	ADCSRA |= (1<<ADSC); // –∑–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤–æ–µ –ê–¶–ü –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
 136:main.c        **** 
 137:main.c        **** 	unsigned char sym;
 138:main.c        **** 
 139:main.c        **** 	while(1){
 140:main.c        **** 		sym = getCharOfUSART();
 141:main.c        **** 		
 142:main.c        **** 		//=====================================
 143:main.c        **** 		//	–ë–ª–æ–∫–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –∫–æ–º–∞–Ω–¥ –æ—Ç –ü–ö
 144:main.c        **** 		//=====================================
 145:main.c        **** 		if (sym == pcToMcuStartMeasureComm[commCount]){
 146:main.c        **** 			commCount ++;
 147:main.c        **** 			if (commCount == sizeof(pcToMcuStartMeasureComm)){
 148:main.c        **** 				pcCommand = DO_START_SM;
 149:main.c        **** 				commCount = 0;
 150:main.c        **** 			}
 151:main.c        **** 		} else if (sym == pcToMcuStopMeasureComm[commCount]){
 152:main.c        **** 			commCount ++;
 153:main.c        **** 			if (commCount == sizeof(pcToMcuStopMeasureComm)){
 154:main.c        **** 				pcCommand = DO_STOP_SM;
 155:main.c        **** 				commCount = 0;
 156:main.c        **** 			}
 157:main.c        **** 		}
 158:main.c        **** 
 159:main.c        **** 		//=========================================
 160:main.c        **** 		//	–ë–ª–æ–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
 161:main.c        **** 		//	–æ—Ç –ø–æ–ª—É—á–µ–Ω–Ω–æ–π –∫–æ–º–∞–Ω–¥—ã –æ—Ç –ü–ö
 162:main.c        **** 		//=========================================
 163:main.c        **** 		switch(pcCommand){
 164:main.c        **** 			case STDBY:
 165:main.c        **** 				break;
 166:main.c        **** 
 167:main.c        **** 			case DO_START_SM:
 168:main.c        **** 				if (isBlockTC1 == false){
 169:main.c        **** 					sendCharToUSART('o');
 170:main.c        **** 					sendCharToUSART('p');
 171:main.c        **** 					cli();
 172:main.c        **** 					turnOnTC1();
 173:main.c        **** 					sei();
 174:main.c        **** 				}
 175:main.c        **** 				break;
 176:main.c        **** 
 177:main.c        **** 			case DO_STOP_SM:
 178:main.c        **** 				btnStateFlag = false;
 179:main.c        **** 				break;
 180:main.c        **** 		}
 181:main.c        **** 
 182:main.c        **** 	}
 183:main.c        **** }
 184:main.c        **** 
 185:main.c        **** // –ü—Ä–∏–µ–º —Å–∏–º–≤–æ–ª–∞ –ø–æ usart`—É –≤ –±—É—Ñ–µ—Ä
 186:main.c        **** ISR(USART_RXC_vect){ 
  15               		.loc 1 186 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 8F93      		push r24
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 24, -4
  32               	/* prologue: Signal */
  33               	/* frame size = 0 */
  34               	/* stack size = 4 */
  35               	.L__stack_usage = 4
 187:main.c        ****    usartRxBuf = UDR;  
  36               		.loc 1 187 0
  37 000c 8CB1      		in r24,0xc
  38 000e 8093 0000 		sts usartRxBuf,r24
  39               	/* epilogue start */
 188:main.c        **** } 
  40               		.loc 1 188 0
  41 0012 8F91      		pop r24
  42 0014 0F90      		pop r0
  43 0016 0FBE      		out __SREG__,r0
  44 0018 0F90      		pop r0
  45 001a 1F90      		pop r1
  46 001c 1895      		reti
  47               		.cfi_endproc
  48               	.LFE12:
  50               	.global	__vector_14
  52               	__vector_14:
  53               	.LFB13:
 189:main.c        **** 
 190:main.c        **** // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –æ—Ç –∞—Ü–ø
 191:main.c        **** ISR(ADC_vect){
  54               		.loc 1 191 0
  55               		.cfi_startproc
  56 001e 1F92      		push r1
  57               	.LCFI3:
  58               		.cfi_def_cfa_offset 3
  59               		.cfi_offset 1, -2
  60 0020 0F92      		push r0
  61               	.LCFI4:
  62               		.cfi_def_cfa_offset 4
  63               		.cfi_offset 0, -3
  64 0022 0FB6      		in r0,__SREG__
  65 0024 0F92      		push r0
  66 0026 1124      		clr __zero_reg__
  67 0028 2F93      		push r18
  68               	.LCFI5:
  69               		.cfi_def_cfa_offset 5
  70               		.cfi_offset 18, -4
  71 002a 8F93      		push r24
  72               	.LCFI6:
  73               		.cfi_def_cfa_offset 6
  74               		.cfi_offset 24, -5
  75 002c 9F93      		push r25
  76               	.LCFI7:
  77               		.cfi_def_cfa_offset 7
  78               		.cfi_offset 25, -6
  79               	/* prologue: Signal */
  80               	/* frame size = 0 */
  81               	/* stack size = 6 */
  82               	.L__stack_usage = 6
 192:main.c        **** 	// —Å—á–∏—Ç—ã–≤–∞–µ–º –º–ª–∞–¥—à–∏–π –∏ —Å—Ç–∞—Ä—à–∏–π –±–∞–π—Ç—ã —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ê–¶-–ø—Ä–µ
 193:main.c        **** 	lowByte = ADCL;
  83               		.loc 1 193 0
  84 002e 84B1      		in r24,0x4
  85 0030 8093 0000 		sts lowByte,r24
 194:main.c        **** 	adcResult = (ADCH<<8)|lowByte;
  86               		.loc 1 194 0
  87 0034 25B1      		in r18,0x5
  88 0036 8091 0000 		lds r24,lowByte
  89 003a 90E0      		ldi r25,0
  90 003c 922B      		or r25,r18
  91 003e 9093 0000 		sts adcResult+1,r25
  92 0042 8093 0000 		sts adcResult,r24
 195:main.c        **** 
 196:main.c        **** 	// –∑–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤–æ–µ –ê–¶-–ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
 197:main.c        **** 	ADCSRA |= (1<<ADSC);
  93               		.loc 1 197 0
  94 0046 369A      		sbi 0x6,6
  95               	/* epilogue start */
 198:main.c        **** }
  96               		.loc 1 198 0
  97 0048 9F91      		pop r25
  98 004a 8F91      		pop r24
  99 004c 2F91      		pop r18
 100 004e 0F90      		pop r0
 101 0050 0FBE      		out __SREG__,r0
 102 0052 0F90      		pop r0
 103 0054 1F90      		pop r1
 104 0056 1895      		reti
 105               		.cfi_endproc
 106               	.LFE13:
 108               	.global	__vector_1
 110               	__vector_1:
 111               	.LFB14:
 199:main.c        **** 
 200:main.c        **** // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∞ –¥–ª—è –∑–∞–ø—É—Å–∫–∞/–æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–æ—Ü–µ–µ—Å–∞ –∏–∑
 201:main.c        **** ISR(INT0_vect){
 112               		.loc 1 201 0
 113               		.cfi_startproc
 114 0058 1F92      		push r1
 115               	.LCFI8:
 116               		.cfi_def_cfa_offset 3
 117               		.cfi_offset 1, -2
 118 005a 0F92      		push r0
 119               	.LCFI9:
 120               		.cfi_def_cfa_offset 4
 121               		.cfi_offset 0, -3
 122 005c 0FB6      		in r0,__SREG__
 123 005e 0F92      		push r0
 124 0060 1124      		clr __zero_reg__
 125 0062 2F93      		push r18
 126               	.LCFI10:
 127               		.cfi_def_cfa_offset 5
 128               		.cfi_offset 18, -4
 129 0064 8F93      		push r24
 130               	.LCFI11:
 131               		.cfi_def_cfa_offset 6
 132               		.cfi_offset 24, -5
 133 0066 9F93      		push r25
 134               	.LCFI12:
 135               		.cfi_def_cfa_offset 7
 136               		.cfi_offset 25, -6
 137               	/* prologue: Signal */
 138               	/* frame size = 0 */
 139               	/* stack size = 6 */
 140               	.L__stack_usage = 6
 202:main.c        **** 	// start measuring
 203:main.c        **** 	if (btnStateFlag == false){
 141               		.loc 1 203 0
 142 0068 8091 0000 		lds r24,btnStateFlag
 143 006c 8111      		cpse r24,__zero_reg__
 144 006e 00C0      		rjmp .L4
 204:main.c        **** 		btnStateFlag = true;
 145               		.loc 1 204 0
 146 0070 81E0      		ldi r24,lo8(1)
 147 0072 8093 0000 		sts btnStateFlag,r24
 148 0076 00C0      		rjmp .L9
 149               	.L4:
 205:main.c        **** 		pcCommand = DO_START_SM;
 206:main.c        **** 	// stop measuring
 207:main.c        **** 	} else if (btnStateFlag == true){
 150               		.loc 1 207 0
 151 0078 8091 0000 		lds r24,btnStateFlag
 152 007c 8823      		tst r24
 153 007e 01F0      		breq .L5
 208:main.c        **** 		btnStateFlag = false;
 154               		.loc 1 208 0
 155 0080 1092 0000 		sts btnStateFlag,__zero_reg__
 209:main.c        **** 		pcCommand = DO_STOP_SM;
 156               		.loc 1 209 0
 157 0084 82E0      		ldi r24,lo8(2)
 158               	.L9:
 159 0086 8093 0000 		sts pcCommand,r24
 160               	.L5:
 161               	.LVL0:
 162               	.LBB27:
 163               	.LBB28:
 164               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165               		.loc 2 163 0
 166 008a 2FEF      		ldi r18,lo8(589823)
 167 008c 8FEF      		ldi r24,hi8(589823)
 168 008e 98E0      		ldi r25,hlo8(589823)
 169 0090 2150      		1: subi r18,1
 170 0092 8040      		sbci r24,0
 171 0094 9040      		sbci r25,0
 172 0096 01F4      		brne 1b
 173 0098 00C0      		rjmp .
 174 009a 0000      		nop
 175               	/* epilogue start */
 176               	.LBE28:
 177               	.LBE27:
 210:main.c        **** 	}
 211:main.c        **** 
 212:main.c        **** 	_delay_ms(200); // –∞–Ω—Ç–∏–¥—Ä–µ–±–∏–∑–≥
 213:main.c        **** }
 178               		.loc 1 213 0
 179 009c 9F91      		pop r25
 180 009e 8F91      		pop r24
 181 00a0 2F91      		pop r18
 182 00a2 0F90      		pop r0
 183 00a4 0FBE      		out __SREG__,r0
 184 00a6 0F90      		pop r0
 185 00a8 1F90      		pop r1
 186 00aa 1895      		reti
 187               		.cfi_endproc
 188               	.LFE14:
 190               	.global	initUSART
 192               	initUSART:
 193               	.LFB17:
 214:main.c        **** 
 215:main.c        **** 
 216:main.c        **** 
 217:main.c        **** ISR(TIMER1_OVF_vect){
 218:main.c        **** 	// –≤ –∫–∞–∫–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—å—Å—è –¥–≤–∏–∂–µ–Ω–∏–µ –®–î
 219:main.c        **** 	// false - –ø—Ä—è–º–æ–µ ; true - –æ–±—Ä–∞—Ç–Ω–æ–µ
 220:main.c        **** 	static bool isDisableForward = false;
 221:main.c        **** 	// —Å—á–µ—Ç—á–∏–∫ —Å–æ—Å—Ç—è–Ω–∏–π –æ–±–º–æ—Ç–æ–∫ –®–î
 222:main.c        **** 	static signed char stepCount = 0;
 223:main.c        **** 	// —Å—á–µ—Ç—á–∏–∫ —à–∞–≥–æ–≤ –®–î –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è
 224:main.c        **** 	static int smProgressCount = 0;
 225:main.c        **** 
 226:main.c        **** 	// –ø—Ä—è–º–æ–π —Ö–æ–¥ –®–î - –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–∑–º–µ—Ä–µ–Ω–∏–π
 227:main.c        **** 	if(smProgressCount < SM_FULL_MSR_STEPS && !isDisableForward){
 228:main.c        **** 		if (pcCommand == DO_START_SM){
 229:main.c        **** 
 230:main.c        **** 			SM_PORT = smTableNormalStep[stepCount];
 231:main.c        **** 			stepCount ++;
 232:main.c        **** 			if (stepCount > 3) stepCount = 0;
 233:main.c        **** 
 234:main.c        **** 			sendCharToUSART((unsigned char)(adcResult/4));
 235:main.c        **** 
 236:main.c        **** 			smProgressCount ++;
 237:main.c        **** 
 238:main.c        **** 		}else if (pcCommand == DO_STOP_SM){
 239:main.c        **** 			isDisableForward = true;
 240:main.c        **** 			stepCount = 3;
 241:main.c        **** 		}
 242:main.c        **** 	}else if(!isDisableForward){
 243:main.c        **** 		isDisableForward = true;
 244:main.c        **** 		stepCount = 3;
 245:main.c        **** 		_delay_ms(300);
 246:main.c        **** 	}
 247:main.c        **** 
 248:main.c        **** 	// –æ–±—Ä–∞—Ç–Ω—ã–π —Ö–æ–¥ –®–î - –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –≤ –∏—Å—Ö–æ–¥–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
 249:main.c        **** 	if (smProgressCount > 0 && isDisableForward){
 250:main.c        **** 		SM_PORT = smTableNormalStep[stepCount];
 251:main.c        **** 		stepCount --;
 252:main.c        **** 		if (stepCount < 0) stepCount = 3;
 253:main.c        **** 
 254:main.c        **** 		smProgressCount --;
 255:main.c        **** 	}
 256:main.c        **** 
 257:main.c        **** 	// –æ—Å—Ç–∞–Ω–æ–∫–∞ –®–î
 258:main.c        **** 	if (smProgressCount == 0 && isDisableForward){
 259:main.c        **** 		isDisableForward = false;
 260:main.c        **** 		stepCount = 0;
 261:main.c        **** 		smProgressCount = 0;
 262:main.c        **** 		turnOffTC1();
 263:main.c        **** 	}
 264:main.c        **** 
 265:main.c        **** 
 266:main.c        **** 	TCNT1 = TCNT1_START_VAL;
 267:main.c        **** }
 268:main.c        **** 
 269:main.c        **** 
 270:main.c        **** /* –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ—Ä—Ç–æ–≤ –≤/–≤ */
 271:main.c        **** void initIO(void){
 272:main.c        **** 	/* –ù–∞—Å—Ç–ø—Ä–∏–≤–∞–µ–º –Ω–∞ –í–´–•–û–î –ø–æ—Ä—Ç—ã –∫ –∫–æ—Ç–æ—Ä—ã–º –ø–æ–¥–∫–ª—á–µ–Ω –¥–≤–∏–≥–∞
 273:main.c        **** 	SetBit(SM_DDR, SM_WIRE_1);
 274:main.c        **** 	SetBit(SM_DDR, SM_WIRE_2);
 275:main.c        **** 	SetBit(SM_DDR, SM_WIRE_3);
 276:main.c        **** 	SetBit(SM_DDR, SM_WIRE_4);
 277:main.c        **** 
 278:main.c        **** 	stopSM();
 279:main.c        **** 
 280:main.c        **** 	/* –ù–∞—Å—Ç—Ä–∏–≤–∞–µ–º –Ω–∞ –í–•–û–î –ø–æ—Ä—Ç –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –æ–ø—Ç–æ-–ø—Ä–µ—Ä—ã–≤
 281:main.c        **** 	ClearBit(OPTO_SENSOR_DDR, OPTO_SENSOR);
 282:main.c        **** 	
 283:main.c        **** 	/* –ù–∞—Å—Ç—Ä–∏–≤–∞–µ–º –Ω–∞ –í–´–•–û–î –ø–æ—Ä—Ç –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è state led  */
 284:main.c        **** 	SetBit(STATE_LED_DDR, STATE_LED);
 285:main.c        **** }
 286:main.c        **** 
 287:main.c        **** void initUSART(){
 194               		.loc 1 287 0
 195               		.cfi_startproc
 196               	/* prologue: function */
 197               	/* frame size = 0 */
 198               	/* stack size = 0 */
 199               	.L__stack_usage = 0
 288:main.c        **** 	//UBRR=95 @ 9600 –±–æ–¥ –ø—Ä–∏ 14,7456 MHz (U2X = 0)
 289:main.c        **** 	//UBRR=51 @ 9600 –±–æ–¥ –ø—Ä–∏ 8 MHz (U2X = 0)
 290:main.c        **** 	// –ø—Ä–∏–º–µ—Ä–Ω–æ 60 –≤—ã–±/—Å –¥–ª—è 1 –∫–∞–Ω–∞–ª–∞ ???!!!
 291:main.c        **** 	UBRRH = 0;
 200               		.loc 1 291 0
 201 00ac 10BC      		out 0x20,__zero_reg__
 292:main.c        **** 	UBRRL = 51; 
 202               		.loc 1 292 0
 203 00ae 83E3      		ldi r24,lo8(51)
 204 00b0 89B9      		out 0x9,r24
 293:main.c        **** 	
 294:main.c        **** 	UCSRB=(1<<RXCIE)|(1<<RXEN)|(1<<TXEN); //—Ä–∞–∑—Ä. –ø—Ä–µ—Ä—ã–≤ –ø—Ä–∏ –ø—Ä–∏–µ–º–µ, —Ä–∞–∑—Ä –ø—Ä–
 205               		.loc 1 294 0
 206 00b2 88E9      		ldi r24,lo8(-104)
 207 00b4 8AB9      		out 0xa,r24
 295:main.c        **** 	UCSRC=(1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);  //—Ä–∞–∑–º–µ—Ä —Å–ª–æ–≤–∞ 8 —Ä–∞–∑—Ä—è–¥–æ–≤
 208               		.loc 1 295 0
 209 00b6 86E8      		ldi r24,lo8(-122)
 210 00b8 80BD      		out 0x20,r24
 211 00ba 0895      		ret
 212               		.cfi_endproc
 213               	.LFE17:
 215               	.global	initADC
 217               	initADC:
 218               	.LFB18:
 296:main.c        **** }
 297:main.c        **** 
 298:main.c        **** 
 299:main.c        **** // –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –ê–¶–ü
 300:main.c        **** void initADC(void){
 219               		.loc 1 300 0
 220               		.cfi_startproc
 221               	/* prologue: function */
 222               	/* frame size = 0 */
 223               	/* stack size = 0 */
 224               	.L__stack_usage = 0
 301:main.c        **** 	ADCSRA |= (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); // –ø—Ä–µ–¥–¥–µ–ª–∏—Ç–µ–ª—å –Ω–∞ 128
 225               		.loc 1 301 0
 226 00bc 86B1      		in r24,0x6
 227 00be 8760      		ori r24,lo8(7)
 228 00c0 86B9      		out 0x6,r24
 302:main.c        **** 	ADCSRA |= (1<<ADIE);                        // —Ä–∞–∑—Ä–µ—à–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –æ—Ç –∞—Ü–ø
 229               		.loc 1 302 0
 230 00c2 339A      		sbi 0x6,3
 303:main.c        **** 	ADCSRA |= (1<<ADEN);                        // —Ä–∞–∑—Ä–µ—à–∞–µ–º —Ä–∞–±–æ—Ç—É –ê–¶–ü
 231               		.loc 1 303 0
 232 00c4 379A      		sbi 0x6,7
 304:main.c        **** 
 305:main.c        **** 	ADMUX |= (1<<REFS0)|(1<<REFS1);             // —Ä–∞–±–æ—Ç–∞ –æ—Ç –≤–Ω—É—Ç—Ä. –ò–û–ù 2,56 –í
 233               		.loc 1 305 0
 234 00c6 87B1      		in r24,0x7
 235 00c8 806C      		ori r24,lo8(-64)
 236 00ca 87B9      		out 0x7,r24
 306:main.c        **** 	ADMUX|=(0<<MUX3)|(0<<MUX2)|(0<<MUX1)|(0<<MUX0);
 237               		.loc 1 306 0
 238 00cc 87B1      		in r24,0x7
 239 00ce 87B9      		out 0x7,r24
 240 00d0 0895      		ret
 241               		.cfi_endproc
 242               	.LFE18:
 244               	.global	initExtInt0
 246               	initExtInt0:
 247               	.LFB19:
 307:main.c        **** }
 308:main.c        **** 
 309:main.c        **** // –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –æ—Ç –≤–Ω–µ—à–Ω–µ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫ (–∫–Ω–æ–ø–∫–∏)
 310:main.c        **** void initExtInt0(){
 248               		.loc 1 310 0
 249               		.cfi_startproc
 250               	/* prologue: function */
 251               	/* frame size = 0 */
 252               	/* stack size = 0 */
 253               	.L__stack_usage = 0
 311:main.c        **** 	// —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–µ –ø–æ –Ω–∏–∑–∫–æ–º—É —É—Ä–æ–≤–Ω—é –Ω–∞ –≤—ã–≤–æ–¥–µ INT0
 312:main.c        **** 	ClearBit(MCUCR, ISC00);
 254               		.loc 1 312 0
 255 00d2 85B7      		in r24,0x35
 256 00d4 8E7F      		andi r24,lo8(-2)
 257 00d6 85BF      		out 0x35,r24
 313:main.c        **** 	ClearBit(MCUCR, ISC01);
 258               		.loc 1 313 0
 259 00d8 85B7      		in r24,0x35
 260 00da 8D7F      		andi r24,lo8(-3)
 261 00dc 85BF      		out 0x35,r24
 314:main.c        **** 	// —Ä–µ–∑—Ä–µ—â–∞–µ–º –≤–Ω–µ—à–Ω–∏–µ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
 315:main.c        **** 	SetBit(GICR, INT0);
 262               		.loc 1 315 0
 263 00de 8BB7      		in r24,0x3b
 264 00e0 8064      		ori r24,lo8(64)
 265 00e2 8BBF      		out 0x3b,r24
 266 00e4 0895      		ret
 267               		.cfi_endproc
 268               	.LFE19:
 270               	.global	turnOnTC1
 272               	turnOnTC1:
 273               	.LFB20:
 316:main.c        **** }
 317:main.c        **** 
 318:main.c        **** 
 319:main.c        **** // –ó–∞–ø—É—Å–∫ –¢–°1 
 320:main.c        **** void turnOnTC1(){
 274               		.loc 1 320 0
 275               		.cfi_startproc
 276               	/* prologue: function */
 277               	/* frame size = 0 */
 278               	/* stack size = 0 */
 279               	.L__stack_usage = 0
 321:main.c        **** 	isBlockTC1 = true;
 280               		.loc 1 321 0
 281 00e6 81E0      		ldi r24,lo8(1)
 282 00e8 8093 0000 		sts isBlockTC1,r24
 322:main.c        **** 	// —Ä–∞–∑—Ä–µ—à–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –ø—Ä–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–∏
 323:main.c        **** 	SetBit(TIMSK, TOIE1);
 283               		.loc 1 323 0
 284 00ec 89B7      		in r24,0x39
 285 00ee 8460      		ori r24,lo8(4)
 286 00f0 89BF      		out 0x39,r24
 324:main.c        **** 
 325:main.c        **** 	// —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–µ–ª–∏—Ç–µ–ª—å —á–∞—Å—Ç–æ—Ç—ã 64
 326:main.c        **** 	SetBit(TCCR1B, CS10);
 287               		.loc 1 326 0
 288 00f2 8EB5      		in r24,0x2e
 289 00f4 8160      		ori r24,lo8(1)
 290 00f6 8EBD      		out 0x2e,r24
 327:main.c        **** 	SetBit(TCCR1B, CS11);
 291               		.loc 1 327 0
 292 00f8 8EB5      		in r24,0x2e
 293 00fa 8260      		ori r24,lo8(2)
 294 00fc 8EBD      		out 0x2e,r24
 328:main.c        **** 	ClearBit(TCCR1B, CS12);
 295               		.loc 1 328 0
 296 00fe 8EB5      		in r24,0x2e
 297 0100 8B7F      		andi r24,lo8(-5)
 298 0102 8EBD      		out 0x2e,r24
 329:main.c        **** 	
 330:main.c        **** 	// —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
 331:main.c        **** 	// –≤ —ç—Ç–æ–º —Ä–µ–∂–∏–º–µ OCR1A –Ω–µ–ª—å–∑—è –∏–∑–º–µ–Ω–∏—Ç—å, OCR1A = 0xFFFF
 332:main.c        **** 	ClearBit(TCCR1A, WGM10);
 299               		.loc 1 332 0
 300 0104 8FB5      		in r24,0x2f
 301 0106 8E7F      		andi r24,lo8(-2)
 302 0108 8FBD      		out 0x2f,r24
 333:main.c        **** 	ClearBit(TCCR1A, WGM11);
 303               		.loc 1 333 0
 304 010a 8FB5      		in r24,0x2f
 305 010c 8D7F      		andi r24,lo8(-3)
 306 010e 8FBD      		out 0x2f,r24
 334:main.c        **** 	ClearBit(TCCR1B, WGM12);
 307               		.loc 1 334 0
 308 0110 8EB5      		in r24,0x2e
 309 0112 877F      		andi r24,lo8(-9)
 310 0114 8EBD      		out 0x2e,r24
 335:main.c        **** 	ClearBit(TCCR1B, WGM13);
 311               		.loc 1 335 0
 312 0116 8EB5      		in r24,0x2e
 313 0118 8F7E      		andi r24,lo8(-17)
 314 011a 8EBD      		out 0x2e,r24
 336:main.c        **** 
 337:main.c        **** 	// –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–∏–º —á–∞—Å—Ç–æ—Ç—É —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ–Ω–∏—è
 338:main.c        **** 	TCNT1 = TCNT1_START_VAL;
 315               		.loc 1 338 0
 316 011c 80E0      		ldi r24,0
 317 011e 9AEF      		ldi r25,lo8(-6)
 318 0120 9DBD      		out 0x2c+1,r25
 319 0122 8CBD      		out 0x2c,r24
 320 0124 0895      		ret
 321               		.cfi_endproc
 322               	.LFE20:
 324               	.global	sendCharToUSART
 326               	sendCharToUSART:
 327               	.LFB22:
 339:main.c        **** }
 340:main.c        **** 
 341:main.c        **** //–û—Ç–∫–ª—é—á–∞–µ–º –¢–°1
 342:main.c        **** void turnOffTC1(){
 343:main.c        **** 	cli();
 344:main.c        **** 	// –≤—ã–∫–ª—é—á–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞
 345:main.c        **** 	ClearBit(TCCR1B, CS10);
 346:main.c        **** 	ClearBit(TCCR1B, CS11);
 347:main.c        **** 	ClearBit(TCCR1B, CS12);
 348:main.c        **** 
 349:main.c        **** 	stopSM();
 350:main.c        **** 
 351:main.c        **** 	pcCommand = DO_STOP_SM;
 352:main.c        **** 	isBlockTC1 = false;
 353:main.c        **** 	sei();
 354:main.c        **** }
 355:main.c        **** 
 356:main.c        **** // –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–º–≤–æ–ª–∞ –ø–æ usart`—É
 357:main.c        **** void sendCharToUSART(unsigned char sym){
 328               		.loc 1 357 0
 329               		.cfi_startproc
 330               	/* prologue: function */
 331               	/* frame size = 0 */
 332               	/* stack size = 0 */
 333               	.L__stack_usage = 0
 334               	.LVL1:
 335               	.L17:
 358:main.c        **** 	while(!(UCSRA & (1<<UDRE)));
 336               		.loc 1 358 0 discriminator 1
 337 0126 5D9B      		sbis 0xb,5
 338 0128 00C0      		rjmp .L17
 359:main.c        **** 	UDR = sym;  
 339               		.loc 1 359 0
 340 012a 8CB9      		out 0xc,r24
 341 012c 0895      		ret
 342               		.cfi_endproc
 343               	.LFE22:
 345               	.global	getCharOfUSART
 347               	getCharOfUSART:
 348               	.LFB23:
 360:main.c        **** }
 361:main.c        **** 
 362:main.c        **** // —á—Ç–µ–Ω–∏–µ –±—É—Ñ–µ—Ä–∞ usart
 363:main.c        **** unsigned char getCharOfUSART(void){
 349               		.loc 1 363 0
 350               		.cfi_startproc
 351               	/* prologue: function */
 352               	/* frame size = 0 */
 353               	/* stack size = 0 */
 354               	.L__stack_usage = 0
 355               	.LVL2:
 356               	.LBB29:
 357               	.LBB30:
 358               	.LBB31:
 359               		.file 3 "/usr/lib/avr/include/util/atomic.h"
   1:/usr/lib/avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/avr/include/util/atomic.h **** 
   4:/usr/lib/avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/avr/include/util/atomic.h **** 
   7:/usr/lib/avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/avr/include/util/atomic.h **** 
  10:/usr/lib/avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/avr/include/util/atomic.h **** 
  15:/usr/lib/avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/avr/include/util/atomic.h **** 
  19:/usr/lib/avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/avr/include/util/atomic.h **** */
  31:/usr/lib/avr/include/util/atomic.h **** 
  32:/usr/lib/avr/include/util/atomic.h **** /* $Id$ */
  33:/usr/lib/avr/include/util/atomic.h **** 
  34:/usr/lib/avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/avr/include/util/atomic.h **** 
  37:/usr/lib/avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/avr/include/util/atomic.h **** 
  40:/usr/lib/avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/avr/include/util/atomic.h **** {
  44:/usr/lib/avr/include/util/atomic.h ****     sei();
  45:/usr/lib/avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/avr/include/util/atomic.h **** }
  47:/usr/lib/avr/include/util/atomic.h **** 
  48:/usr/lib/avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/avr/include/util/atomic.h **** {
  50:/usr/lib/avr/include/util/atomic.h ****     cli();
 360               		.loc 3 50 0
 361               	/* #APP */
 362               	 ;  50 "/usr/lib/avr/include/util/atomic.h" 1
 363 012e F894      		cli
 364               	 ;  0 "" 2
 365               	.LVL3:
 366               	/* #NOAPP */
 367               	.LBE31:
 368               	.LBE30:
 364:main.c        **** 	unsigned char tmp;
 365:main.c        **** 	ATOMIC_BLOCK(ATOMIC_FORCEON){
 366:main.c        **** 		tmp = usartRxBuf;
 369               		.loc 1 366 0
 370 0130 8091 0000 		lds r24,usartRxBuf
 371               	.LVL4:
 367:main.c        **** 		usartRxBuf = 0;
 372               		.loc 1 367 0
 373 0134 1092 0000 		sts usartRxBuf,__zero_reg__
 374               	.LVL5:
 375               	.LBB32:
 376               	.LBB33:
  51:/usr/lib/avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/avr/include/util/atomic.h **** }
  53:/usr/lib/avr/include/util/atomic.h **** 
  54:/usr/lib/avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/avr/include/util/atomic.h **** {
  56:/usr/lib/avr/include/util/atomic.h ****     sei();
 377               		.loc 3 56 0
 378               	/* #APP */
 379               	 ;  56 "/usr/lib/avr/include/util/atomic.h" 1
 380 0138 7894      		sei
 381               	 ;  0 "" 2
  57:/usr/lib/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 382               		.loc 3 57 0
 383               	/* #NOAPP */
 384               	.LBE33:
 385               	.LBE32:
 386               	.LBE29:
 368:main.c        **** 	}
 369:main.c        **** 	return tmp;  
 370:main.c        **** }
 387               		.loc 1 370 0
 388 013a 0895      		ret
 389               		.cfi_endproc
 390               	.LFE23:
 392               	.global	stopSM
 394               	stopSM:
 395               	.LFB25:
 371:main.c        **** 
 372:main.c        **** 
 373:main.c        **** 
 374:main.c        **** // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è (–ø–∞—Ä–∫–æ–≤–∫–∏) –®–î –≤ –∏—Å—Ö–æ–¥–Ω–æ–º (–Ω–∞—á–∞–
 375:main.c        **** // –û–±—Ä–∞—Ç–Ω—ã–π —Ö–æ–¥ –®–î –¥–æ –∑–∞–∫—Ä—ã—Ç–∏—è –æ–∫–Ω–∞ –æ–ø—Ç–æ-–ø—Ä–µ—Ä—ã–≤–∞—Ç–µ–ª—è
 376:main.c        **** bool checkSMInBeginPos(){
 377:main.c        **** 	cli();
 378:main.c        **** 	while (IsClearBit(OPTO_SENSOR_PIN, OPTO_SENSOR)){
 379:main.c        **** 		SM_PORT = smTableNormalStep[3];
 380:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 381:main.c        **** 	
 382:main.c        **** 		SM_PORT = smTableNormalStep[2];
 383:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 384:main.c        **** 		
 385:main.c        **** 		SM_PORT = smTableNormalStep[1];
 386:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 387:main.c        **** 		
 388:main.c        **** 		SM_PORT = smTableNormalStep[0];
 389:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 390:main.c        **** 	}
 391:main.c        **** 	stopSM();
 392:main.c        **** 	sei();
 393:main.c        **** 	return true;
 394:main.c        **** }
 395:main.c        **** 
 396:main.c        **** // –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –®–î - —Å–Ω—è—Ç–∏—è –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è —Å —É–ø—Ä–∞–≤–ª—è—é—â–∏—Ö –≤—ã–≤–æ–¥
 397:main.c        **** void stopSM(){
 396               		.loc 1 397 0
 397               		.cfi_startproc
 398               	/* prologue: function */
 399               	/* frame size = 0 */
 400               	/* stack size = 0 */
 401               	.L__stack_usage = 0
 398:main.c        **** 	ClearBit(SM_PORT, SM_WIRE_1);
 402               		.loc 1 398 0
 403 013c 9498      		cbi 0x12,4
 399:main.c        **** 	ClearBit(SM_PORT, SM_WIRE_2);
 404               		.loc 1 399 0
 405 013e 9598      		cbi 0x12,5
 400:main.c        **** 	ClearBit(SM_PORT, SM_WIRE_3);
 406               		.loc 1 400 0
 407 0140 9698      		cbi 0x12,6
 401:main.c        **** 	ClearBit(SM_PORT, SM_WIRE_4);
 408               		.loc 1 401 0
 409 0142 9798      		cbi 0x12,7
 410 0144 0895      		ret
 411               		.cfi_endproc
 412               	.LFE25:
 414               	.global	initIO
 416               	initIO:
 417               	.LFB16:
 271:main.c        **** 	/* –ù–∞—Å—Ç–ø—Ä–∏–≤–∞–µ–º –Ω–∞ –í–´–•–û–î –ø–æ—Ä—Ç—ã –∫ –∫–æ—Ç–æ—Ä—ã–º –ø–æ–¥–∫–ª—á–µ–Ω –¥–≤–∏–≥–∞
 418               		.loc 1 271 0
 419               		.cfi_startproc
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
 273:main.c        **** 	SetBit(SM_DDR, SM_WIRE_2);
 424               		.loc 1 273 0
 425 0146 8C9A      		sbi 0x11,4
 274:main.c        **** 	SetBit(SM_DDR, SM_WIRE_3);
 426               		.loc 1 274 0
 427 0148 8D9A      		sbi 0x11,5
 275:main.c        **** 	SetBit(SM_DDR, SM_WIRE_4);
 428               		.loc 1 275 0
 429 014a 8E9A      		sbi 0x11,6
 276:main.c        **** 
 430               		.loc 1 276 0
 431 014c 8F9A      		sbi 0x11,7
 278:main.c        **** 
 432               		.loc 1 278 0
 433 014e 00D0      		rcall stopSM
 434               	.LVL6:
 281:main.c        **** 	
 435               		.loc 1 281 0
 436 0150 B898      		cbi 0x17,0
 284:main.c        **** }
 437               		.loc 1 284 0
 438 0152 B99A      		sbi 0x17,1
 439 0154 0895      		ret
 440               		.cfi_endproc
 441               	.LFE16:
 443               	.global	turnOffTC1
 445               	turnOffTC1:
 446               	.LFB21:
 342:main.c        **** 	cli();
 447               		.loc 1 342 0
 448               		.cfi_startproc
 449               	/* prologue: function */
 450               	/* frame size = 0 */
 451               	/* stack size = 0 */
 452               	.L__stack_usage = 0
 343:main.c        **** 	// –≤—ã–∫–ª—é—á–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞
 453               		.loc 1 343 0
 454               	/* #APP */
 455               	 ;  343 "main.c" 1
 456 0156 F894      		cli
 457               	 ;  0 "" 2
 345:main.c        **** 	ClearBit(TCCR1B, CS11);
 458               		.loc 1 345 0
 459               	/* #NOAPP */
 460 0158 8EB5      		in r24,0x2e
 461 015a 8E7F      		andi r24,lo8(-2)
 462 015c 8EBD      		out 0x2e,r24
 346:main.c        **** 	ClearBit(TCCR1B, CS12);
 463               		.loc 1 346 0
 464 015e 8EB5      		in r24,0x2e
 465 0160 8D7F      		andi r24,lo8(-3)
 466 0162 8EBD      		out 0x2e,r24
 347:main.c        **** 
 467               		.loc 1 347 0
 468 0164 8EB5      		in r24,0x2e
 469 0166 8B7F      		andi r24,lo8(-5)
 470 0168 8EBD      		out 0x2e,r24
 349:main.c        **** 
 471               		.loc 1 349 0
 472 016a 00D0      		rcall stopSM
 473               	.LVL7:
 351:main.c        **** 	isBlockTC1 = false;
 474               		.loc 1 351 0
 475 016c 82E0      		ldi r24,lo8(2)
 476 016e 8093 0000 		sts pcCommand,r24
 352:main.c        **** 	sei();
 477               		.loc 1 352 0
 478 0172 1092 0000 		sts isBlockTC1,__zero_reg__
 353:main.c        **** }
 479               		.loc 1 353 0
 480               	/* #APP */
 481               	 ;  353 "main.c" 1
 482 0176 7894      		sei
 483               	 ;  0 "" 2
 484               	/* #NOAPP */
 485 0178 0895      		ret
 486               		.cfi_endproc
 487               	.LFE21:
 489               	.global	__vector_8
 491               	__vector_8:
 492               	.LFB15:
 217:main.c        **** 	// –≤ –∫–∞–∫–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—å—Å—è –¥–≤–∏–∂–µ–Ω–∏–µ –®–î
 493               		.loc 1 217 0
 494               		.cfi_startproc
 495 017a 1F92      		push r1
 496               	.LCFI13:
 497               		.cfi_def_cfa_offset 3
 498               		.cfi_offset 1, -2
 499 017c 0F92      		push r0
 500               	.LCFI14:
 501               		.cfi_def_cfa_offset 4
 502               		.cfi_offset 0, -3
 503 017e 0FB6      		in r0,__SREG__
 504 0180 0F92      		push r0
 505 0182 1124      		clr __zero_reg__
 506 0184 2F93      		push r18
 507               	.LCFI15:
 508               		.cfi_def_cfa_offset 5
 509               		.cfi_offset 18, -4
 510 0186 3F93      		push r19
 511               	.LCFI16:
 512               		.cfi_def_cfa_offset 6
 513               		.cfi_offset 19, -5
 514 0188 4F93      		push r20
 515               	.LCFI17:
 516               		.cfi_def_cfa_offset 7
 517               		.cfi_offset 20, -6
 518 018a 5F93      		push r21
 519               	.LCFI18:
 520               		.cfi_def_cfa_offset 8
 521               		.cfi_offset 21, -7
 522 018c 6F93      		push r22
 523               	.LCFI19:
 524               		.cfi_def_cfa_offset 9
 525               		.cfi_offset 22, -8
 526 018e 7F93      		push r23
 527               	.LCFI20:
 528               		.cfi_def_cfa_offset 10
 529               		.cfi_offset 23, -9
 530 0190 8F93      		push r24
 531               	.LCFI21:
 532               		.cfi_def_cfa_offset 11
 533               		.cfi_offset 24, -10
 534 0192 9F93      		push r25
 535               	.LCFI22:
 536               		.cfi_def_cfa_offset 12
 537               		.cfi_offset 25, -11
 538 0194 AF93      		push r26
 539               	.LCFI23:
 540               		.cfi_def_cfa_offset 13
 541               		.cfi_offset 26, -12
 542 0196 BF93      		push r27
 543               	.LCFI24:
 544               		.cfi_def_cfa_offset 14
 545               		.cfi_offset 27, -13
 546 0198 EF93      		push r30
 547               	.LCFI25:
 548               		.cfi_def_cfa_offset 15
 549               		.cfi_offset 30, -14
 550 019a FF93      		push r31
 551               	.LCFI26:
 552               		.cfi_def_cfa_offset 16
 553               		.cfi_offset 31, -15
 554               	/* prologue: Signal */
 555               	/* frame size = 0 */
 556               	/* stack size = 15 */
 557               	.L__stack_usage = 15
 227:main.c        **** 		if (pcCommand == DO_START_SM){
 558               		.loc 1 227 0
 559 019c 8091 0000 		lds r24,smProgressCount.1701
 560 01a0 9091 0000 		lds r25,smProgressCount.1701+1
 561 01a4 2091 0000 		lds r18,isDisableForward.1699
 562 01a8 8A30      		cpi r24,10
 563 01aa 9441      		sbci r25,20
 564 01ac 04F4      		brge .L23
 227:main.c        **** 		if (pcCommand == DO_START_SM){
 565               		.loc 1 227 0 is_stmt 0 discriminator 1
 566 01ae 2111      		cpse r18,__zero_reg__
 567 01b0 00C0      		rjmp .L23
 228:main.c        **** 
 568               		.loc 1 228 0 is_stmt 1
 569 01b2 8091 0000 		lds r24,pcCommand
 570 01b6 8130      		cpi r24,lo8(1)
 571 01b8 01F4      		brne .L24
 230:main.c        **** 			stepCount ++;
 572               		.loc 1 230 0
 573 01ba E091 0000 		lds r30,stepCount.1700
 574 01be FF27      		clr r31
 575 01c0 E7FD      		sbrc r30,7
 576 01c2 F095      		com r31
 577 01c4 E050      		subi r30,lo8(-(smTableNormalStep))
 578 01c6 F040      		sbci r31,hi8(-(smTableNormalStep))
 579 01c8 8081      		ld r24,Z
 580 01ca 82BB      		out 0x12,r24
 231:main.c        **** 			if (stepCount > 3) stepCount = 0;
 581               		.loc 1 231 0
 582 01cc 8091 0000 		lds r24,stepCount.1700
 583 01d0 8F5F      		subi r24,lo8(-(1))
 232:main.c        **** 
 584               		.loc 1 232 0
 585 01d2 8430      		cpi r24,lo8(4)
 586 01d4 04F4      		brge .L25
 231:main.c        **** 			if (stepCount > 3) stepCount = 0;
 587               		.loc 1 231 0
 588 01d6 8093 0000 		sts stepCount.1700,r24
 589 01da 00C0      		rjmp .L26
 590               	.L25:
 232:main.c        **** 
 591               		.loc 1 232 0 discriminator 1
 592 01dc 1092 0000 		sts stepCount.1700,__zero_reg__
 593               	.L26:
 234:main.c        **** 
 594               		.loc 1 234 0
 595 01e0 8091 0000 		lds r24,adcResult
 596 01e4 9091 0000 		lds r25,adcResult+1
 597 01e8 9695      		lsr r25
 598 01ea 8795      		ror r24
 599 01ec 9695      		lsr r25
 600 01ee 8795      		ror r24
 601 01f0 00D0      		rcall sendCharToUSART
 602               	.LVL8:
 236:main.c        **** 
 603               		.loc 1 236 0
 604 01f2 8091 0000 		lds r24,smProgressCount.1701
 605 01f6 9091 0000 		lds r25,smProgressCount.1701+1
 606 01fa 0196      		adiw r24,1
 607 01fc 9093 0000 		sts smProgressCount.1701+1,r25
 608 0200 8093 0000 		sts smProgressCount.1701,r24
 609 0204 00C0      		rjmp .L27
 610               	.L24:
 238:main.c        **** 			isDisableForward = true;
 611               		.loc 1 238 0
 612 0206 8091 0000 		lds r24,pcCommand
 613 020a 8230      		cpi r24,lo8(2)
 614 020c 01F4      		brne .L27
 239:main.c        **** 			stepCount = 3;
 615               		.loc 1 239 0
 616 020e 81E0      		ldi r24,lo8(1)
 617 0210 8093 0000 		sts isDisableForward.1699,r24
 240:main.c        **** 		}
 618               		.loc 1 240 0
 619 0214 83E0      		ldi r24,lo8(3)
 620 0216 8093 0000 		sts stepCount.1700,r24
 621 021a 00C0      		rjmp .L27
 622               	.L23:
 242:main.c        **** 		isDisableForward = true;
 623               		.loc 1 242 0
 624 021c 2111      		cpse r18,__zero_reg__
 625 021e 00C0      		rjmp .L27
 243:main.c        **** 		stepCount = 3;
 626               		.loc 1 243 0
 627 0220 81E0      		ldi r24,lo8(1)
 628 0222 8093 0000 		sts isDisableForward.1699,r24
 244:main.c        **** 		_delay_ms(300);
 629               		.loc 1 244 0
 630 0226 83E0      		ldi r24,lo8(3)
 631 0228 8093 0000 		sts stepCount.1700,r24
 632               	.LVL9:
 633               	.LBB34:
 634               	.LBB35:
 635               		.loc 2 163 0
 636 022c 8FEF      		ldi r24,lo8(884735)
 637 022e 9FE7      		ldi r25,hi8(884735)
 638 0230 2DE0      		ldi r18,hlo8(884735)
 639 0232 8150      		1: subi r24,1
 640 0234 9040      		sbci r25,0
 641 0236 2040      		sbci r18,0
 642 0238 01F4      		brne 1b
 643 023a 00C0      		rjmp .
 644 023c 0000      		nop
 645               	.LVL10:
 646               	.L27:
 647               	.LBE35:
 648               	.LBE34:
 249:main.c        **** 		SM_PORT = smTableNormalStep[stepCount];
 649               		.loc 1 249 0
 650 023e 8091 0000 		lds r24,smProgressCount.1701
 651 0242 9091 0000 		lds r25,smProgressCount.1701+1
 652 0246 1816      		cp __zero_reg__,r24
 653 0248 1906      		cpc __zero_reg__,r25
 654 024a 04F4      		brge .L28
 249:main.c        **** 		SM_PORT = smTableNormalStep[stepCount];
 655               		.loc 1 249 0 is_stmt 0 discriminator 1
 656 024c 8091 0000 		lds r24,isDisableForward.1699
 657 0250 8823      		tst r24
 658 0252 01F0      		breq .L28
 250:main.c        **** 		stepCount --;
 659               		.loc 1 250 0 is_stmt 1
 660 0254 E091 0000 		lds r30,stepCount.1700
 661 0258 FF27      		clr r31
 662 025a E7FD      		sbrc r30,7
 663 025c F095      		com r31
 664 025e E050      		subi r30,lo8(-(smTableNormalStep))
 665 0260 F040      		sbci r31,hi8(-(smTableNormalStep))
 666 0262 8081      		ld r24,Z
 667 0264 82BB      		out 0x12,r24
 251:main.c        **** 		if (stepCount < 0) stepCount = 3;
 668               		.loc 1 251 0
 669 0266 8091 0000 		lds r24,stepCount.1700
 670 026a 8150      		subi r24,lo8(-(-1))
 252:main.c        **** 
 671               		.loc 1 252 0
 672 026c 87FD      		sbrc r24,7
 252:main.c        **** 
 673               		.loc 1 252 0 is_stmt 0 discriminator 1
 674 026e 83E0      		ldi r24,lo8(3)
 675               	.L38:
 676 0270 8093 0000 		sts stepCount.1700,r24
 254:main.c        **** 	}
 677               		.loc 1 254 0 is_stmt 1 discriminator 1
 678 0274 8091 0000 		lds r24,smProgressCount.1701
 679 0278 9091 0000 		lds r25,smProgressCount.1701+1
 680 027c 0197      		sbiw r24,1
 681 027e 9093 0000 		sts smProgressCount.1701+1,r25
 682 0282 8093 0000 		sts smProgressCount.1701,r24
 683               	.L28:
 258:main.c        **** 		isDisableForward = false;
 684               		.loc 1 258 0
 685 0286 8091 0000 		lds r24,smProgressCount.1701
 686 028a 9091 0000 		lds r25,smProgressCount.1701+1
 687 028e 892B      		or r24,r25
 688 0290 01F4      		brne .L31
 258:main.c        **** 		isDisableForward = false;
 689               		.loc 1 258 0 is_stmt 0 discriminator 1
 690 0292 8091 0000 		lds r24,isDisableForward.1699
 691 0296 8823      		tst r24
 692 0298 01F0      		breq .L31
 259:main.c        **** 		stepCount = 0;
 693               		.loc 1 259 0 is_stmt 1
 694 029a 1092 0000 		sts isDisableForward.1699,__zero_reg__
 260:main.c        **** 		smProgressCount = 0;
 695               		.loc 1 260 0
 696 029e 1092 0000 		sts stepCount.1700,__zero_reg__
 261:main.c        **** 		turnOffTC1();
 697               		.loc 1 261 0
 698 02a2 1092 0000 		sts smProgressCount.1701+1,__zero_reg__
 699 02a6 1092 0000 		sts smProgressCount.1701,__zero_reg__
 262:main.c        **** 	}
 700               		.loc 1 262 0
 701 02aa 00D0      		rcall turnOffTC1
 702               	.LVL11:
 703               	.L31:
 266:main.c        **** }
 704               		.loc 1 266 0
 705 02ac 80E0      		ldi r24,0
 706 02ae 9AEF      		ldi r25,lo8(-6)
 707 02b0 9DBD      		out 0x2c+1,r25
 708 02b2 8CBD      		out 0x2c,r24
 709               	/* epilogue start */
 267:main.c        **** 
 710               		.loc 1 267 0
 711 02b4 FF91      		pop r31
 712 02b6 EF91      		pop r30
 713 02b8 BF91      		pop r27
 714 02ba AF91      		pop r26
 715 02bc 9F91      		pop r25
 716 02be 8F91      		pop r24
 717 02c0 7F91      		pop r23
 718 02c2 6F91      		pop r22
 719 02c4 5F91      		pop r21
 720 02c6 4F91      		pop r20
 721 02c8 3F91      		pop r19
 722 02ca 2F91      		pop r18
 723 02cc 0F90      		pop r0
 724 02ce 0FBE      		out __SREG__,r0
 725 02d0 0F90      		pop r0
 726 02d2 1F90      		pop r1
 727 02d4 1895      		reti
 728               		.cfi_endproc
 729               	.LFE15:
 731               	.global	checkSMInBeginPos
 733               	checkSMInBeginPos:
 734               	.LFB24:
 376:main.c        **** 	cli();
 735               		.loc 1 376 0
 736               		.cfi_startproc
 737               	/* prologue: function */
 738               	/* frame size = 0 */
 739               	/* stack size = 0 */
 740               	.L__stack_usage = 0
 377:main.c        **** 	while (IsClearBit(OPTO_SENSOR_PIN, OPTO_SENSOR)){
 741               		.loc 1 377 0
 742               	/* #APP */
 743               	 ;  377 "main.c" 1
 744 02d6 F894      		cli
 745               	 ;  0 "" 2
 379:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 746               		.loc 1 379 0
 747               	/* #NOAPP */
 748 02d8 80E1      		ldi r24,lo8(16)
 382:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 749               		.loc 1 382 0
 750 02da 90E2      		ldi r25,lo8(32)
 385:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 751               		.loc 1 385 0
 752 02dc 20E4      		ldi r18,lo8(64)
 388:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 753               		.loc 1 388 0
 754 02de 30E8      		ldi r19,lo8(-128)
 755               	.L40:
 378:main.c        **** 		SM_PORT = smTableNormalStep[3];
 756               		.loc 1 378 0 discriminator 1
 757 02e0 B099      		sbic 0x16,0
 758 02e2 00C0      		rjmp .L42
 379:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 759               		.loc 1 379 0
 760 02e4 82BB      		out 0x12,r24
 761               	.LVL12:
 762               	.LBB36:
 763               	.LBB37:
 764               		.loc 2 163 0
 765 02e6 EFEF      		ldi r30,lo8(-28673)
 766 02e8 FFE8      		ldi r31,hi8(-28673)
 767 02ea 3197      		1: sbiw r30,1
 768 02ec 01F4      		brne 1b
 769 02ee 00C0      		rjmp .
 770 02f0 0000      		nop
 771               	.LBE37:
 772               	.LBE36:
 382:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 773               		.loc 1 382 0
 774 02f2 92BB      		out 0x12,r25
 775               	.LVL13:
 776               	.LBB38:
 777               	.LBB39:
 778               		.loc 2 163 0
 779 02f4 EFEF      		ldi r30,lo8(-28673)
 780 02f6 FFE8      		ldi r31,hi8(-28673)
 781 02f8 3197      		1: sbiw r30,1
 782 02fa 01F4      		brne 1b
 783 02fc 00C0      		rjmp .
 784 02fe 0000      		nop
 785               	.LBE39:
 786               	.LBE38:
 385:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 787               		.loc 1 385 0
 788 0300 22BB      		out 0x12,r18
 789               	.LVL14:
 790               	.LBB40:
 791               	.LBB41:
 792               		.loc 2 163 0
 793 0302 EFEF      		ldi r30,lo8(-28673)
 794 0304 FFE8      		ldi r31,hi8(-28673)
 795 0306 3197      		1: sbiw r30,1
 796 0308 01F4      		brne 1b
 797 030a 00C0      		rjmp .
 798 030c 0000      		nop
 799               	.LBE41:
 800               	.LBE40:
 388:main.c        **** 		_delay_ms(SM_DELAY_STEP_MS);
 801               		.loc 1 388 0
 802 030e 32BB      		out 0x12,r19
 803               	.LVL15:
 804               	.LBB42:
 805               	.LBB43:
 806               		.loc 2 163 0
 807 0310 EFEF      		ldi r30,lo8(-28673)
 808 0312 FFE8      		ldi r31,hi8(-28673)
 809 0314 3197      		1: sbiw r30,1
 810 0316 01F4      		brne 1b
 811 0318 00C0      		rjmp .
 812 031a 0000      		nop
 813 031c 00C0      		rjmp .L40
 814               	.LVL16:
 815               	.L42:
 816               	.LBE43:
 817               	.LBE42:
 391:main.c        **** 	sei();
 818               		.loc 1 391 0
 819 031e 00D0      		rcall stopSM
 820               	.LVL17:
 392:main.c        **** 	return true;
 821               		.loc 1 392 0
 822               	/* #APP */
 823               	 ;  392 "main.c" 1
 824 0320 7894      		sei
 825               	 ;  0 "" 2
 394:main.c        **** 
 826               		.loc 1 394 0
 827               	/* #NOAPP */
 828 0322 81E0      		ldi r24,lo8(1)
 829 0324 0895      		ret
 830               		.cfi_endproc
 831               	.LFE24:
 833               		.section	.text.startup,"ax",@progbits
 834               	.global	main
 836               	main:
 837               	.LFB11:
 125:main.c        **** 	cli();
 838               		.loc 1 125 0
 839               		.cfi_startproc
 840               	/* prologue: function */
 841               	/* frame size = 0 */
 842               	/* stack size = 0 */
 843               	.L__stack_usage = 0
 126:main.c        **** 	initIO();
 844               		.loc 1 126 0
 845               	/* #APP */
 846               	 ;  126 "main.c" 1
 847 0000 F894      		cli
 848               	 ;  0 "" 2
 127:main.c        **** 	initUSART();
 849               		.loc 1 127 0
 850               	/* #NOAPP */
 851 0002 00D0      		rcall initIO
 852               	.LVL18:
 128:main.c        **** 	initADC();
 853               		.loc 1 128 0
 854 0004 00D0      		rcall initUSART
 855               	.LVL19:
 129:main.c        **** 	initExtInt0();
 856               		.loc 1 129 0
 857 0006 00D0      		rcall initADC
 858               	.LVL20:
 130:main.c        **** 	sei();
 859               		.loc 1 130 0
 860 0008 00D0      		rcall initExtInt0
 861               	.LVL21:
 131:main.c        **** 
 862               		.loc 1 131 0
 863               	/* #APP */
 864               	 ;  131 "main.c" 1
 865 000a 7894      		sei
 866               	 ;  0 "" 2
 133:main.c        **** 
 867               		.loc 1 133 0
 868               	/* #NOAPP */
 869 000c 00D0      		rcall checkSMInBeginPos
 870               	.LVL22:
 135:main.c        **** 
 871               		.loc 1 135 0
 872 000e 369A      		sbi 0x6,6
 154:main.c        **** 				commCount = 0;
 873               		.loc 1 154 0
 874 0010 C2E0      		ldi r28,lo8(2)
 148:main.c        **** 				commCount = 0;
 875               		.loc 1 148 0
 876 0012 D1E0      		ldi r29,lo8(1)
 877               	.L44:
 140:main.c        **** 		
 878               		.loc 1 140 0
 879 0014 00D0      		rcall getCharOfUSART
 880               	.LVL23:
 145:main.c        **** 			commCount ++;
 881               		.loc 1 145 0
 882 0016 2091 0000 		lds r18,commCount
 883 001a 3091 0000 		lds r19,commCount+1
 884 001e F901      		movw r30,r18
 885 0020 E050      		subi r30,lo8(-(pcToMcuStartMeasureComm))
 886 0022 F040      		sbci r31,hi8(-(pcToMcuStartMeasureComm))
 887 0024 9081      		ld r25,Z
 888 0026 8913      		cpse r24,r25
 889 0028 00C0      		rjmp .L46
 146:main.c        **** 			if (commCount == sizeof(pcToMcuStartMeasureComm)){
 890               		.loc 1 146 0
 891 002a 2F5F      		subi r18,-1
 892 002c 3F4F      		sbci r19,-1
 893 002e 3093 0000 		sts commCount+1,r19
 894 0032 2093 0000 		sts commCount,r18
 147:main.c        **** 				pcCommand = DO_START_SM;
 895               		.loc 1 147 0
 896 0036 2330      		cpi r18,3
 897 0038 3105      		cpc r19,__zero_reg__
 898 003a 01F4      		brne .L48
 148:main.c        **** 				commCount = 0;
 899               		.loc 1 148 0
 900 003c D093 0000 		sts pcCommand,r29
 901 0040 00C0      		rjmp .L52
 902               	.L46:
 151:main.c        **** 			commCount ++;
 903               		.loc 1 151 0
 904 0042 F901      		movw r30,r18
 905 0044 E050      		subi r30,lo8(-(pcToMcuStopMeasureComm))
 906 0046 F040      		sbci r31,hi8(-(pcToMcuStopMeasureComm))
 907 0048 9081      		ld r25,Z
 908 004a 8913      		cpse r24,r25
 909 004c 00C0      		rjmp .L48
 152:main.c        **** 			if (commCount == sizeof(pcToMcuStopMeasureComm)){
 910               		.loc 1 152 0
 911 004e 2F5F      		subi r18,-1
 912 0050 3F4F      		sbci r19,-1
 913 0052 3093 0000 		sts commCount+1,r19
 914 0056 2093 0000 		sts commCount,r18
 153:main.c        **** 				pcCommand = DO_STOP_SM;
 915               		.loc 1 153 0
 916 005a 2330      		cpi r18,3
 917 005c 3105      		cpc r19,__zero_reg__
 918 005e 01F4      		brne .L48
 154:main.c        **** 				commCount = 0;
 919               		.loc 1 154 0
 920 0060 C093 0000 		sts pcCommand,r28
 921               	.L52:
 155:main.c        **** 			}
 922               		.loc 1 155 0
 923 0064 1092 0000 		sts commCount+1,__zero_reg__
 924 0068 1092 0000 		sts commCount,__zero_reg__
 925               	.L48:
 163:main.c        **** 			case STDBY:
 926               		.loc 1 163 0
 927 006c 8091 0000 		lds r24,pcCommand
 928               	.LVL24:
 929 0070 8130      		cpi r24,lo8(1)
 930 0072 01F0      		breq .L50
 931 0074 8230      		cpi r24,lo8(2)
 932 0076 01F4      		brne .L44
 178:main.c        **** 				break;
 933               		.loc 1 178 0
 934 0078 1092 0000 		sts btnStateFlag,__zero_reg__
 179:main.c        **** 		}
 935               		.loc 1 179 0
 936 007c 00C0      		rjmp .L44
 937               	.L50:
 168:main.c        **** 					sendCharToUSART('o');
 938               		.loc 1 168 0
 939 007e 8091 0000 		lds r24,isBlockTC1
 940 0082 8111      		cpse r24,__zero_reg__
 941 0084 00C0      		rjmp .L44
 169:main.c        **** 					sendCharToUSART('p');
 942               		.loc 1 169 0
 943 0086 8FE6      		ldi r24,lo8(111)
 944 0088 00D0      		rcall sendCharToUSART
 945               	.LVL25:
 170:main.c        **** 					cli();
 946               		.loc 1 170 0
 947 008a 80E7      		ldi r24,lo8(112)
 948 008c 00D0      		rcall sendCharToUSART
 949               	.LVL26:
 171:main.c        **** 					turnOnTC1();
 950               		.loc 1 171 0
 951               	/* #APP */
 952               	 ;  171 "main.c" 1
 953 008e F894      		cli
 954               	 ;  0 "" 2
 172:main.c        **** 					sei();
 955               		.loc 1 172 0
 956               	/* #NOAPP */
 957 0090 00D0      		rcall turnOnTC1
 958               	.LVL27:
 173:main.c        **** 				}
 959               		.loc 1 173 0
 960               	/* #APP */
 961               	 ;  173 "main.c" 1
 962 0092 7894      		sei
 963               	 ;  0 "" 2
 964               	/* #NOAPP */
 965 0094 00C0      		rjmp .L44
 966               		.cfi_endproc
 967               	.LFE11:
 969               		.text
 970               	.global	blinkLed1r
 972               	blinkLed1r:
 973               	.LFB26:
 402:main.c        **** }
 403:main.c        **** 
 404:main.c        **** 
 405:main.c        **** 
 406:main.c        **** void blinkLed1r(){
 974               		.loc 1 406 0
 975               		.cfi_startproc
 976               	/* prologue: function */
 977               	/* frame size = 0 */
 978               	/* stack size = 0 */
 979               	.L__stack_usage = 0
 407:main.c        **** 	SetBit(STATE_LED_PORT, STATE_LED);
 980               		.loc 1 407 0
 981 0326 C19A      		sbi 0x18,1
 982               	.LVL28:
 983               	.LBB44:
 984               	.LBB45:
 985               		.loc 2 163 0
 986 0328 2FEF      		ldi r18,lo8(294911)
 987 032a 8FE7      		ldi r24,hi8(294911)
 988 032c 94E0      		ldi r25,hlo8(294911)
 989 032e 2150      		1: subi r18,1
 990 0330 8040      		sbci r24,0
 991 0332 9040      		sbci r25,0
 992 0334 01F4      		brne 1b
 993 0336 00C0      		rjmp .
 994 0338 0000      		nop
 995               	.LBE45:
 996               	.LBE44:
 408:main.c        **** 	_delay_ms(100);
 409:main.c        **** 	ClearBit(STATE_LED_PORT, STATE_LED);
 997               		.loc 1 409 0
 998 033a C198      		cbi 0x18,1
 999 033c 0895      		ret
 1000               		.cfi_endproc
 1001               	.LFE26:
 1003               	.global	blinkLed2r
 1005               	blinkLed2r:
 1006               	.LFB27:
 410:main.c        **** }
 411:main.c        **** 
 412:main.c        **** void blinkLed2r(){
 1007               		.loc 1 412 0
 1008               		.cfi_startproc
 1009               	/* prologue: function */
 1010               	/* frame size = 0 */
 1011               	/* stack size = 0 */
 1012               	.L__stack_usage = 0
 413:main.c        **** 	SetBit(STATE_LED_PORT, STATE_LED);
 1013               		.loc 1 413 0
 1014 033e C19A      		sbi 0x18,1
 1015               	.LVL29:
 1016               	.LBB46:
 1017               	.LBB47:
 1018               		.loc 2 163 0
 1019 0340 29E9      		ldi r18,lo8(88473)
 1020 0342 89E5      		ldi r24,hi8(88473)
 1021 0344 91E0      		ldi r25,hlo8(88473)
 1022 0346 2150      		1: subi r18,1
 1023 0348 8040      		sbci r24,0
 1024 034a 9040      		sbci r25,0
 1025 034c 01F4      		brne 1b
 1026 034e 0000      		nop
 1027               	.LBE47:
 1028               	.LBE46:
 414:main.c        **** 	_delay_ms(30);
 415:main.c        **** 	ClearBit(STATE_LED_PORT, STATE_LED);
 1029               		.loc 1 415 0
 1030 0350 C198      		cbi 0x18,1
 1031               	.LVL30:
 1032               	.LBB48:
 1033               	.LBB49:
 1034               		.loc 2 163 0
 1035 0352 29E9      		ldi r18,lo8(88473)
 1036 0354 89E5      		ldi r24,hi8(88473)
 1037 0356 91E0      		ldi r25,hlo8(88473)
 1038 0358 2150      		1: subi r18,1
 1039 035a 8040      		sbci r24,0
 1040 035c 9040      		sbci r25,0
 1041 035e 01F4      		brne 1b
 1042 0360 0000      		nop
 1043               	.LBE49:
 1044               	.LBE48:
 416:main.c        **** 	_delay_ms(30);
 417:main.c        **** 	SetBit(STATE_LED_PORT, STATE_LED);
 1045               		.loc 1 417 0
 1046 0362 C19A      		sbi 0x18,1
 1047               	.LVL31:
 1048               	.LBB50:
 1049               	.LBB51:
 1050               		.loc 2 163 0
 1051 0364 29E9      		ldi r18,lo8(88473)
 1052 0366 89E5      		ldi r24,hi8(88473)
 1053 0368 91E0      		ldi r25,hlo8(88473)
 1054 036a 2150      		1: subi r18,1
 1055 036c 8040      		sbci r24,0
 1056 036e 9040      		sbci r25,0
 1057 0370 01F4      		brne 1b
 1058 0372 0000      		nop
 1059               	.LBE51:
 1060               	.LBE50:
 418:main.c        **** 	_delay_ms(30);
 419:main.c        **** 	ClearBit(STATE_LED_PORT, STATE_LED);
 1061               		.loc 1 419 0
 1062 0374 C198      		cbi 0x18,1
 1063 0376 0895      		ret
 1064               		.cfi_endproc
 1065               	.LFE27:
 1067               		.local	stepCount.1700
 1068               		.comm	stepCount.1700,1,1
 1069               		.local	isDisableForward.1699
 1070               		.comm	isDisableForward.1699,1,1
 1071               		.local	smProgressCount.1701
 1072               		.comm	smProgressCount.1701,2,1
 1073               	.global	pcCommand
 1074               		.section .bss
 1077               	pcCommand:
 1078 0000 00        		.zero	1
 1079               	.global	commCount
 1082               	commCount:
 1083 0001 0000      		.zero	2
 1084               	.global	pcToMcuStopMeasureComm
 1085               		.data
 1088               	pcToMcuStopMeasureComm:
 1089 0000 61        		.byte	97
 1090 0001 62        		.byte	98
 1091 0002 6B        		.byte	107
 1092               	.global	pcToMcuStartMeasureComm
 1095               	pcToMcuStartMeasureComm:
 1096 0003 61        		.byte	97
 1097 0004 71        		.byte	113
 1098 0005 6C        		.byte	108
 1099               	.global	smTableNormalStep
 1100               		.section	.rodata
 1103               	smTableNormalStep:
 1104 0000 80        		.byte	-128
 1105 0001 40        		.byte	64
 1106 0002 20        		.byte	32
 1107 0003 10        		.byte	16
 1108               		.comm	adcResult,2,1
 1109               		.comm	lowByte,1,1
 1110               	.global	usartRxBuf
 1111               		.section .bss
 1114               	usartRxBuf:
 1115 0003 00        		.zero	1
 1116               	.global	btnStateFlag
 1119               	btnStateFlag:
 1120 0004 00        		.zero	1
 1121               	.global	isBlockTC1
 1124               	isBlockTC1:
 1125 0005 00        		.zero	1
 1126               		.text
 1127               	.Letext0:
 1128               		.file 4 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cczHXLOj.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cczHXLOj.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cczHXLOj.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cczHXLOj.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cczHXLOj.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cczHXLOj.s:12     .text:0000000000000000 __vector_11
     /tmp/cczHXLOj.s:1114   .bss:0000000000000003 usartRxBuf
     /tmp/cczHXLOj.s:52     .text:000000000000001e __vector_14
                            *COM*:0000000000000001 lowByte
                            *COM*:0000000000000002 adcResult
     /tmp/cczHXLOj.s:110    .text:0000000000000058 __vector_1
     /tmp/cczHXLOj.s:1119   .bss:0000000000000004 btnStateFlag
     /tmp/cczHXLOj.s:1077   .bss:0000000000000000 pcCommand
     /tmp/cczHXLOj.s:192    .text:00000000000000ac initUSART
     /tmp/cczHXLOj.s:217    .text:00000000000000bc initADC
     /tmp/cczHXLOj.s:246    .text:00000000000000d2 initExtInt0
     /tmp/cczHXLOj.s:272    .text:00000000000000e6 turnOnTC1
     /tmp/cczHXLOj.s:1124   .bss:0000000000000005 isBlockTC1
     /tmp/cczHXLOj.s:326    .text:0000000000000126 sendCharToUSART
     /tmp/cczHXLOj.s:347    .text:000000000000012e getCharOfUSART
     /tmp/cczHXLOj.s:394    .text:000000000000013c stopSM
     /tmp/cczHXLOj.s:416    .text:0000000000000146 initIO
     /tmp/cczHXLOj.s:445    .text:0000000000000156 turnOffTC1
     /tmp/cczHXLOj.s:491    .text:000000000000017a __vector_8
     /tmp/cczHXLOj.s:1070   .bss:0000000000000008 smProgressCount.1701
     /tmp/cczHXLOj.s:1068   .bss:0000000000000007 isDisableForward.1699
                             .bss:0000000000000006 stepCount.1700
     /tmp/cczHXLOj.s:1103   .rodata:0000000000000000 smTableNormalStep
     /tmp/cczHXLOj.s:733    .text:00000000000002d6 checkSMInBeginPos
     /tmp/cczHXLOj.s:836    .text.startup:0000000000000000 main
     /tmp/cczHXLOj.s:1082   .bss:0000000000000001 commCount
     /tmp/cczHXLOj.s:1095   .data:0000000000000003 pcToMcuStartMeasureComm
     /tmp/cczHXLOj.s:1088   .data:0000000000000000 pcToMcuStopMeasureComm
     /tmp/cczHXLOj.s:972    .text:0000000000000326 blinkLed1r
     /tmp/cczHXLOj.s:1005   .text:000000000000033e blinkLed2r

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
